\newpage
\chapter*{Оригинал}
\addcontentsline{toc}{chapter}{Оригинал}
\vspace{-1em}

\chapter{Definition}
A programming language is a formal constructed language designed to
commu\-nicate instructions to a machine, particularly a computer. Programming
languages can be used to create programs to control the behavior of a machine
or to express algorithms.

The earliest programming languages preceded the invention of the digital
com\-puter and were used to direct the behavior of machines such as Jacquard
looms and player pianos. Thousands of different programming languages have been
created, mainly in the computer field, and many more still are being created
every year. Many programming languages require computation to be specified in
an imperative form, while other languages utilize other forms of program
specification such as the declarative form.

The description of a programming language is usually split into the two
compo\-nents of syntax and semantics. Some languages are defined by a
specification document, while other languages have a dominant implementation
that is treated as a reference.

\chapter{History}
\section{Early developments}
The first programming languages designed to communicate instructions to a
computer were written in the~1950s. An early high-level programming language
to be designed for a computer was Plankalk\"{u}l, developed for the German Z3 by
Konrad~Zuse between~1943 and~1945. However, it was not implemented until 1998
and 2000.

John~Mauchly's Short Code, proposed in~1949, was one of the first high-level
languages ever developed for an electronic computer. Unlike machine code, Short
Code statements represented mathematical expressions in understandable form.
However, the program had to be translated into machine code every time it ran,
making the process much slower than running the equivalent machine code.

At the University of Manchester, Alick~Glennie developed Autocode in the
early~1950s. A programming language, it used a compiler to automatically
convert the language into machine code. The first code and compiler was
developed in~1952 for the Mark~1 computer at the University of Manchester
and is considered to be the first compiled high-level programming language.

The second autocode was developed for the Mark~1 by R.~A.~Brooker in~1954 and
was called the ``Mark~1 Autocode''. Brooker also developed an autocode for the
Ferranti~Mercury in the~1950s in conjunction with the University of Manchester.
The version for the EDSAC~2 was devised by D.~F.~Hartley of University of
Cambridge Mathematical Laboratory in~1961. Known as EDSAC~2 Autocode, it was a
straight development from Mercury Autocode adapted for local circumstances, and
was noted for its object code optimisation and source-language diagnostics
which were advanced for the time. A contemporary but separate thread of
develop\-ment, Atlas Autocode was developed for the University of Manchester
Atlas~1 machine.

Another early programming language was devised by Grace Hopper in the US,
called FLOW-MATIC. It was developed for the UNIVAC~I at Remington Rand during
the period from~1955 until~1959. Hopper found that business data processing
customers were uncomfortable with mathematical notation, and in early~1955,
she and her team wrote a specification for an English programming language
and implemented a prototype. The FLOW-MATIC compiler became pub\-licly available
in early~1958 and was substantially complete in~1959. Flow-Matic was a major
influence in the design of COBOL, since only it and its direct descendent AIMACO
were in actual use at the time. The language Fortran was developed at IBM
in the mid ’50s, and became the first widely used high-level general purpose
programming language.

\section{Refinement}
The period from the 1960s to the late 1970s brought the development of the
major language paradigms now in use:
\begin{itemize}
  \item APL introduced array programming and influenced functional
    programming.
  \item ALGOL refined both structured procedural programming and the
    discipline of language specification.
  \item In the 1960s, Simula was the first language designed to support
    object-oriented programming; in the mid-1970s, Smalltalk followed with the
    first ``purely'' object-oriented language.
  \item C was developed between 1969 and 1973 as a system programming
    language, and remains popular.
  \item Prolog, designed in 1972, was the first logic programming language.
  \item In 1978, ML built a polymorphic type system on top of Lisp,
    pioneering statically typed functional programming languages.
\end{itemize}

The 1960s and 1970s also saw considerable debate over the merits of
structured programming, and whether programming languages should be
designed to support it.

\section{Consolidation and growth}
The 1980s were years of relative consolidation. C++ combined
object-oriented and systems programming. The United States government
standardized Ada, a systems programming language derived from Pascal and
intended for use by defense contractors. In Japan and elsewhere, vast sums
were spent investigating so-called ``fifth generation'' languages that
incorporated logic programming constructs. The functional languages
community moved to standardize ML and Lisp. Rather than inventing new
paradigms, all of these movements elaborated upon the ideas invented in the
previous decade.

The rapid growth of the Internet in the mid-1990s created opportunities for
new languages. Perl, originally a Unix scripting tool first released in
1987, became common in dynamic websites. Java came to be used for
server-side programming, and bytecode virtual machines became popular again
in commercial settings with their promise of ``Write once, run anywhere''.
These developments were not funda\-mentally novel, rather they were
refinements to existing languages and paradigms, and largely based on the C
family of programming languages.

Programming language evolution continues, in both industry and research.

\chapter{Elements}
All programming languages have some primitive building blocks for the
de\-scription of data and the processes or transformations applied to them.
These primitives are defined by syntactic and semantic rules which describe
their structure and meaning respectively.

\section{Syntax}
A programming language's surface form is known as its syntax. Most
programm\-ing languages are purely textual; they use sequences of text
including words, numbers, and punctuation, much like written natural
languages. On the other hand, there are some programming languages which
are more graphical in nature, using visual relationships between symbols to
specify a program.

The syntax of a language describes the possible combinations of symbols
that form a syntactically correct program. The meaning given to a
combination of symbols is handled by semantics.

\section{Semantics}
\vspace{-1em}
\subsection{Static semantics}
The static semantics defines restrictions on the structure of valid texts
that are hard or impossible to express in standard syntactic formalisms.
For compiled languages, static semantics essentially include those semantic
rules that can be checked at compile time. Examples include checking that
every identifier is declared before it is used or that the labels on the
arms of a case statement are distinct. Many important restrictions of this
type, like checking that identifiers are used in the appropriate context,
or that subroutine calls have the appropriate number and type of arguments,
can be enforced by defining them as rules in a logic called a type system.
Other forms of static analyses like data flow analysis may also be part of
static semantics. Newer programming languages like Java and C\# have
definite assignment analysis, a form of data flow analysis, as part of their
static semantics.

\subsection{Dynamic semantics}
Once data has been specified, the machine must be instructed to perform
operat\-ions on the data. For example, the semantics may define the strategy
by which expressions are evaluated to values, or the manner in which
control structures conditionally execute statements. The dynamic semantics
of a language defines how and when the various constructs of a language
should produce a program behavior. There are many ways of defining execution
semantics. Natural language is often used to specify the execution semantics
of languages commonly used in practice. A significant amount of academic
research went into formal semantics of programming languages, which allow
execution semantics to be specified in a formal manner. Results from this
field of research have seen limited application to programming language
design and implementation outside academia.

\subsection{Type system}
A type system defines how a programming language classifies values and
expressions into types, how it can manipulate those types and how they
interact. The goal of a type system is to verify and usually enforce a
certain level of correctness in programs written in that language by
detecting certain incorrect operations. Any decidable type system involves
a trade-off: while it rejects many incorrect programs, it can also prohibit
some correct, albeit unusual programs. In order to bypass this downside, a
number of languages have type loopholes, usually unchecked casts that may
be used by the programmer to explicitly allow a normally disallowed
operation between different types. In most typed languages, the type system
is used only to type check programs, but a number of languages, usually
functional ones, infer types, relieving the programmer from the need to
write type annotations. The formal design and study of type systems is
known as type theory.

\chapter{Design and implementation}
Programming languages share properties with natural languages related to
their purpose as vehicles for communication, having a syntactic form
separate from its semantics, and showing language families of related
languages branching one from another. But as artificial constructs, they
also differ in fundamental ways from languages that have evolved through
usage. A significant difference is that a programming language can be fully
described and studied in its entirety, since it has a precise and finite
definition. By contrast, natural languages have changing meanings given by
their users in different communities. While constructed lan\-guages are also
artificial languages designed from the ground up with a specific purpose,
they lack the precise and complete semantic definition that a programming
language has.

Many programming languages have been designed from scratch, altered to meet
new needs, and combined with other languages. Many have eventually fallen
into disuse. Although there have been attempts to design one ``universal''
programming language that serves all purposes, all of them have failed to
be generally accepted as filling this role. The need for diverse
programming languages arises from the diversity of contexts in which
languages are used:
\begin{itemize}
  \item Programs range from tiny scripts written by individual hobbyists to
    huge systems written by hundreds of programmers.
  \item Programmers range in expertise from novices who need simplicity above
    all else, to experts who may be comfortable with considerable complexity.
  \item Programs must balance speed, size, and simplicity on systems ranging
    from microcontrollers to supercomputers.
  \item Programs may be written once and not change for generations, or they
    may undergo continual modification.
  \item Programmers may simply differ in their tastes: they may be accustomed
    to discussing problems and expressing them in a particular language.
\end{itemize}

One common trend in the development of programming languages has been to
add more ability to solve problems using a higher level of abstraction. The
earliest programming languages were tied very closely to the underlying
hardware of the computer. As new programming languages have developed,
features have been added that let programmers express ideas that are more
remote from simple translation into underlying hardware instructions.
Because programmers are less tied to the complexity of the computer, their
programs can do more computing with less effort from the programmer. This
lets them write more functionality per time unit.

A language's designers and users must construct a number of artifacts that
govern and enable the practice of programming. The most important of these
artifacts are the language specification and implementation.

\section{Specification}
The specification of a programming language is an artifact that the
language users and the implementors can use to agree upon whether a piece
of source code is a valid program in that language, and if so what its
behavior shall be.

A programming language specification can take several forms, including the
following:
\begin{itemize}
  \item An explicit definition of the syntax, static semantics, and execution
    semantics of the language. While syntax is commonly specified using a
    formal grammar, semantic definitions may be written in natural language,
    or a formal seman\-tics.
  \item A description of the behavior of a translator for the language.
    The syntax and semantics of the language have to be inferred from this
    description, which may be written in natural or a formal language.
  \item A reference or model implementation, sometimes written in the language
    being specified. The syntax and semantics of the language are explicit in
    the behavior of the reference implementation.
\end{itemize}

\section{Implementation}
An implementation of a programming language provides a way to write
prog\-rams in that language and execute them on one or more configurations of
hardware and software. There are, broadly, two approaches to programming
language imple\-mentation: compilation and interpretation. It is generally
possible to implement a lan\-guage using either technique.

The output of a compiler may be executed by hardware or a program called an
interpreter. In some implementations that make use of the interpreter
approach there is no distinct boundary between compiling and interpreting.
For instance, some implementations of BASIC compile and then execute the
source a line at a time.

Programs that are executed directly on the hardware usually run several
orders of magnitude faster than those that are interpreted in software.

One technique for improving the performance of interpreted programs is
just-in-time compilation. Here the virtual machine, just before execution,
translates the blocks of bytecode which are going to be used to machine
code, for direct execution on the hardware.

\chapter{Usage}
Thousands of different programming languages have been created, mainly in
the computing field.

Programming languages differ from most other forms of human expression in
that they require a greater degree of precision and completeness. When
using a natural language to communicate with other people, human authors
and speakers can be ambiguous and make small errors, and still expect their
intent to be under\-stood. However, figuratively speaking, computers ``do
exactly what they are told to do'', and cannot ``understand'' what code the
programmer intended to write. The combination of the language definition, a
program, and the program's inputs must fully specify the external behavior
that occurs when the program is executed, within the domain of control of
that program. On the other hand, ideas about an algorithm can be
communicated to humans without the precision required for execution by
using pseudocode, which interleaves natural language with code written in a
programming language.

A programming language provides a structured mechanism for defining pieces
of data, and the operations or transformations that may be carried out
automatically on that data. A programmer uses the abstractions present in
the language to represent the concepts involved in a computation. These
concepts are represented as a collect\-ion of the simplest elements available.
Programming is the process by which programmers combine these primitives to
compose new programs, or adapt existing ones to new uses or a changing
environment.

Programs for a computer might be executed in a batch process without human
interaction, or a user might type commands in an interactive session of an
interpreter. In this case the ``commands'' are simply programs, whose
execution is chained together. When a language can run its commands through
an interpreter, without compiling, it is called a scripting language.

In 2013 the ten most popular programming languages were: C, Java, PHP,
JavaScript, C++, Python, Shell, Ruby, and Objective-C and C\#.
